^title Введение
^part Добро пожаловать

> Сказки – больше, чем правда, не потому, что в них рассказывается о существовании драконов, а потому, что они говорят нам: драконов можно победить.”
>
> <cite>Нил Гейман</cite>

Я очень рад, что мы пройдем этот путь вместе. Эта книга о реализации
интерпретаторов для языков программирования. Но так же она о том, как
спроектировать язык, достойный реализации. Мне бы хотелось, чтобы эта книга
была у меня в то  время, когда я только начал погружение в языки. Уже в течение
почти десятка лет я пишу её в своей <span name="head">голове</span>.

<aside name="head">

Мои друзья и семья, простите за то, что я был так погружен в собственные мысли!

</aside>

На этих страницах мы последовательно рассмотрим два законченных интерпретатора
для полноценного языка. Полагаю, это ваше первое погружение в эту тему, поэтому
постараюсь покрыть каждую концепцию и строчку кода, которые нужны вам для
построения полной, практичной и быстрой реализации языка программирования.

Чтобы уместить две реализации в одну книгу и не сделать её такой большой, что
можно было бы подпирать дверь, она содержит меньше теории, чем другая подобная
литература. По мере того, как мы будем выстраивать части системы, я буду
рассказывать истории и концепции, которые за ними стоят. Я постараюсь
познакомить вас с профессиональным жаргоном, так что если вы попадете на <span
name="party">коктейльную вечеринку</span>, полную исследователей ЯП (языков
программирования), то впишетесь в неё.

<aside name="party">

Довольно странно, но я оказывался в такой ситуации несколько раз. Вы не 
поверите, сколько некоторые из них могут выпить.

</aside>

Но мы в основном будем тратить наши усилия на то, чтобы язык запустился и
заработал. Это не означает, что теория не важна. Умение рассуждать четко и
<span name="formal">формально</span> о синтаксисе и семантике -- несомненно
важное умение при работе с языком. Однако лично я изучаю что-либо гораздо лучше
на практике. Мне сложно пройти через множество параграфов, полных  абстрактных
понятий, и действительно понять их. Только когда я что-то  запрограммировал,
запустил и отладил, я могу сказать, что действительно  *понимаю* это.

<aside name="formal">

Статическая типизация особенно требует строгого формального обсуждения.
Разработка системы типов схожа с доказательством теоремы в математике.

Как оказалось, это действительно так. В первой половине прошлого века Хаскелл
Карри и  Уильям Алвин Говард разработали доказательство того, что это стороны
одной монеты: [изоморфизм Карри-Говарда][the curry-howard isomorphism].

[the curry-howard isomorphism]: https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B8%D0%B5_%D0%9A%D0%B0%D1%80%D1%80%D0%B8_%E2%80%94_%D0%A5%D0%BE%D0%B2%D0%B0%D1%80%D0%B4%D0%B0

</aside>

Это то, что я хочу донести до вас. Мне хочется, чтобы вы получили твердую
интуицию в том, как в действительности язык живет и дышит. Надеюсь, что позже вы
прочтете и другие, более теоретические книги, когда все концепции будут крепко
держаться в  вашем сознании, закрепленные на полученной здесь основе.

## Для чего это вообще нужно изучать?

Каждое введение в каждой подобной книге имеет такой раздел. Я не знаю, что не
так с языками программирования, что они вызывают такие экзистенциальные
сомнения. Не думаю, что книги по орнитологии волнуются об оправдании своего
существования. Они полагают, что читатель любит птиц и стремится к развитию.

Но с языками программирования несколько иная ситуация. Полагаю, шансы любого из
нас на создание успешного языка программирования общего назначения невелики.
Разработчики языков, широко применяемых во всем мире, могут вместиться в автобус
Фольксваген, даже не поднимая крышу-палатку. Если бы присоединение к этой
элитной группе было *единственной* причиной изучать языки, это занятие
действительно было бы сложно оправдать. К счастью, это не так.

### Маленькие языки повсюду

На каждый успешный язык общего назначения приходятся тысячи успешных нишевых
языков. Раньше мы называли их "маленькие языки", но развитие жаргона приводит
нас к названию "предметно-ориентированные языки" (domain-specific languages).
Это пиджины (промежуточные языки) специально разработанные для конкретных задач.
Например, это могут быть сценарии для приложений, движки шаблонов, форматы
разметки и конфигурационные файлы.

<span name="little"></span>
<img src="image/introduction/little-languages.png" alt="A random selection of little languages." />

<aside name="little">

Случайная выборка некоторых маленьких языков, с которыми вы можете столкнуться.

</aside>

Практически каждый крупный проект разработки ПО нуждается в нескольких из них.
Если возможно, лучше использовать один из существующих, чем создавать свой. Как
только вы задумываетесь о документации, отладчике, поддержке редактором,
подсветке синтаксиса и прочей атрибутике, создание всего этого самостоятельно
превращается в непростую задачу.

Но все еще остается довольно большой шанс того, что вам понадобится состряпать
парсер чего-то, в то время как под рукой не окажется библиотеки, удовлетворяющей
вашим нуждам. А если и *окажется*, вам неизбежно понадобится её отлаживать и
поддерживать, а также ковыряться в её внутренностях.

### Языки -- это проекрасное упражнение

Бегуны на длинные дистанции иногда тренируются с весами на ногах, или на высотах
с очень разреженным воздухом. Когда позже они избавляются от этого, легкость в
конечностях и богатый кислородом воздух позволяют им бежать дальше и быстрее.

Разработка языка -- это настоящий тест ваших навыков программирования. Код здесь
получается сложным, а производительность критична. Нужно владеть рекурсией,
динамическими массивами, деревьями, графами и хэш-таблицами. Вы, вероятно,
будете использовать хэш-таблицы в программировании каждый день, но будете ли вы
*действительно* понимать их? Что ж, после того, как мы создадим их с нуля,
гарантирую, что будете.

Хоть я и хочу показать, что написание языка программирования не такое уж и
страшное, это все еще испытание. Преодолев его, вы станете более сильным
программистом и будете лучше понимать, как использовать структуры данных и
алгоритмы в своей повседневной работе.

### Еще одна причина

Последнюю причину мне тяжело признать, потому что я принимаю её близко к сердцу.
Во время обучения программированию в детстве, я чувствовал что-то волшебное в
языках. Впервые набирая свои программы на BASIC клавишу за клавишей, я не
представлял, как *сам* BASIC был устроен.

Позже, смешение трепета и страха, которое испытывали мои друзья по колледжу по
отношению к курсу компиляторов, убедило меня, что разработчики языков -- это
другой вид людей. Какие-то волшебники, имеющие доступ к мистическим искусствам.

Этот <span name="image">образ</span> очарователен, но у него есть и темная
сторона. *Я* не чувствовал себя волшебником и думал о том, что упустил какое-то
врожденное качество, которое мешало мне присоединиться к их заговору. Так что я
был очарован языками с тех пор как набросал несколько ключевых слов в школьной
тетради, и у меня заняло десятки лет, чтобы набраться смелости и попробовать
действительно изучить их. Это "магическое" качество, чувство особенности,
отталкивало *меня*.

<aside name="image">

Его приверженцы и не планируют с ним бороться. Два фундаментальных текста о
языках программирования содержат [дракона][dragon] и [волшебника][wizard] на
обложках.

[dragon]: https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools
[wizard]: https://mitpress.mit.edu/sicp/full-text/book/book.html

</aside>

Когда я в конце концов начал сколачивать свои собственные маленькие
интерпретаторы, я быстро понял, что, разумеется, там вообще нет никакой магии.
Это просто код, и люди, которые пишут языки -- просто люди.

*Есть* некоторые техники, с которыми вы не очень часто сталкиваетесь вне мира
написания языков, и некоторые из них довольно сложные. Но не сложнее, чем другие
препятствия, которые вы обычно преодолеваете. Надеюсь, что эта книга позволит
вам перебороть этот страх, и, возможно, вы уйдете отсюда более храбрыми, чем
были до этого.

И, кто знает, может быть вы *создадите* следующий великий язык. Кто-то ведь
должен это сделать.

## Как эта книга устроена

Эта книга разделена на три части. Сейчас вы читаете первую из них. Её
предназначение -- сориентировать вас, научить некоторому жаргону, который
используют разработчики языков, и представить вам Lox, язык, который мы будем
реализовывать.

Каждая из двух оставшихся частей создает свой полный интерпретатор Lox. В этих
частях все главы устроены одинаково. Каждая часть берет определенную фичу языка,
обучает концептам, которые за ней лежат, и представляет её реализацию.

Методом проб и ошибок у меня удалось разделить оба интерпретатора на куски по
главам так, чтобы каждый следующий кусок основывался на предыдущем. Начиная с
самой первой главы, у вас будет программа, которую можно запустить и
попробовать. С каждой следующей главой она будет становиться все более
полнофункциональной, пока вы не получите в конце концов полноценный язык.

Помимо богатой и полной остроумия прозы, главы имеют следующие восхитительные
вставки:

### Код

Мы говорим о *ремесле создания* интерпретаторов, так что в этой книге есть
настоящий код. Будет приведена каждая необходимая строка, а врезки расскажут
вам, куда добавить её в вашу постоянно растущую реализацию.

Многие другие книги о языках и их реализации используют такие инструменты как
[Lex][] и <span name="yacc">[Yacc][]</span>, "компиляторы компиляторов"
("compiler-compilers"), чтобы автоматически генерировать исходные файлы
реализации из некоторого высокоуровневого описания. Есть плюсы и минусы
использования таких инструментов и серьезные аргументы -- можно сказать,
религиозные убеждения -- за и против.

<aside name="yacc">

Yacc -- это инструмент, который принимает файл с грамматикой и создает исходные
файлы для компилятора, то есть что-то вроде "компилятора", дающего на выходе
компилятор. Мы будем называть это термином "компилятор компилятора"
("compiler-compiler").

Yacc не первый в своем роде, и именно поэтому он называется "Yacc" -- *Yet
Another* Compiler-Compiler (еще один компилятор компилятора). Более молодой
схожий инструмент [Bison][], назван от игры слов в произношении Yacc как "як".

![A yak.](image/introduction/yak.png)

[bison]: https://en.wikipedia.org/wiki/GNU_bison

Если вы находите все эти отсылки и каламбур очаровательными и забавными, вы
почувствуете себя здесь как дома. Если нет, что ж, чувство юмора у ботаников
наживное.

</aside>

Мы будем воздерживаться его от использования здесь. Я стараюсь не оставить
темных углов, где могут спрятаться магия и неоднозначность, так что мы будем
писать все своими руками. Как увидите, это не так плохо, как звучит, и это
значит, что вы действительно поймете каждую строчку кода и как оба
интерпретатора работают.

[lex]: https://en.wikipedia.org/wiki/Lex_(software)
[yacc]: https://en.wikipedia.org/wiki/Yacc

К коду в книге предъявляются требования, отличные от тех, что предъявляются к
коду в "реальном мире", так что стиль программирования здесь не всегда может
отражать лучшее решение для написания поддерживаемого в продакшнене программного
обеспечения. Если я выгляжу неряшливым, пропуская `private` или объявляя
глобальные переменные, прошу понять, что я стараюсь сохранять код проще в ваших
глазах. Страницы здесь не такие широкие, как в вашей IDE, и каждый символ на
счету.

К тому же код содержит не так много комментариев. Это потому что каждый набор
строк окружен несколькими параграфами, которые, видит Бог, объясняют их. Когда
вы будете писать целую книгу для сопровождения вашей программы, тоже можете
опускать комментарии. В противном случае, вы, выроятно, должны использовать
`//` немного чаще, чем это делаю я.

Чего эта книга *не содержит*, так это описания механизмов компиляции и запуска
кода. Я полагаю, вы сможете сбацать makefile или проект в вашей IDE на выбор,
чтобы запустить код.


### Врезки

Так как книга содержит буквально каждую строчку, необходимую для реализации,
все врезки предельно точны. Кроме того, так как я старался сохранять даже
наполовину написанную программу в рабочем состоянии, иногда мы добавляем
временный код, который будет заменен в последующих врезках.

Врезка со всеми примочками выглядит так:

<div class="codehilite"><pre class="insert-before"><span></span>      <span class="k">default</span><span class="o">:</span>
</pre><div class="source-file"><em>lox/Scanner.java</em><br>
in <em>scanToken</em>()<br>
replace 1 line</div>
<pre class="insert"><span></span>        <span class="k">if</span> <span class="o">(</span><span class="n">isDigit</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="o">{</span>
          <span class="n">number</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="n">Lox</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="n">line</span><span class="o">,</span> <span class="s">&quot;Unexpected character.&quot;</span><span class="o">);</span>
        <span class="o">}</span>
</pre><pre class="insert-after"><span></span>        <span class="k">break</span><span class="o">;</span>
</pre></div>

В центре располагается новый код, добавляемый в этой врезке. Сверху и снизу
могут находиться полупрозрачные строки, которые показывают, куда необходимо
вставить врезку в существующем коде. Также есть небольшая подсказка, которая
подсказывает имя и место в файле. Если она говорит "replace _ lines", значит до
этого между полупрозрачными строками был предыдущий код, который вы должны
заменить на эту врезку.

### Заметки на полях

 <span name="joke">Заметки на полях</span> содержат биографические фрагменты,
 историческую справку, ссылки на связанные темы и рекомендации других областей
 исследования. В них нет ничего такого, что вам *нужно* знать, чтобы понимать
 последующие части книги, так что можете пропускать их, если хотите. Я не буду
 осуждать вас, но могу немного расстроиться.

<aside name="joke">

По крайней мере, некоторые. Большинство из них -- это просто глупые шутки и
любительские рисунки.

</aside>

### Задачи

Каждая глава заканчивается несколькими упражнениями. В отличие от стандартных
вопросов в учебниках, рассчитаных на повтор только что прочитанного материала,
они нацелены на то, чтобы вы изучили *больше*, чем есть в главе. Они сподвигнут
вас отойти от протоптанной тропы и исследовать самим. Для их решения может быть
необходимо изучать другие языки, понимать, как реализовать фичи языка или любым
другим образом действовать самостоятельно. 

Преодолев их, вы приобретете более широкое понимание вещей и, возможно, синяки и
царапины. Но вы можете и пропустить их, если хотите оставаться в пределах
комфортного туристического автобуса. Это ваша книга. 

### Рабочие заметки

Большинство книг о языках программирования на самом деле являются книгами о
*реализации* языков программирования. Но в них редко обсуждается, как
*спроектировать* язык, который позже будет реализован. Реализация - это весело,
потому что она <span name="benchmark">точно определена</span>. Мы, программисты,
видимо, слишком родны с вещами, которые белые и черные, нули и единицы.

<aside name="benchmark">

Я знаю много разработчиков языков, чья карьера основана на этом. Ты засовываешь
спецификацию языка под их дверь, ждешь несколько месяцев, и получаешь код с
тестами производительности на выходе.

</aside>

Лично мне кажется, что в мире уже достаточно реализаций <span name="fortran">
FORTRAN 77</span>. В определенный момент времени вы начинаете разрабатывать
*новый* язык. Как только вы начинаете играть в *эту* игру, человеческая сторона
уравнения становится более значимой. Например, легкость изучения, баланс
инноваций и консерватизма, а также читабельность синтаксиса.

<aside name="fortran">

Надеюсь, язык, в грамматике которого не будет заложена ширина перфокарты.

</aside>

Все это серьезно влияет на успех вашего нового языка. Мне хочется, чтобы ваши
языки были успешными, потому некоторые главы я заканчиваю "рабочими заметками",
маленькими очерками о человеческом аспекте языков программирования. Я не
эксперт в этом -- не уверен, что кто-то действительно эксперт -- так что
воспринимайте это с большой долей скепсиса. Это кроме прочего сделает их более
вкусными, а это моя основная цель. (По-английски "принимать с большой долей
скепсиса" звучит так же, как и "принимать с большой щепоткой соли" - прим.
переводчика).

## Первый интерпретатор

Мы напишем наш первый интерпретатор, под названием jlox, на Java, фокусируясь на
*концепциях*. Чтобы реализовать семантику языка, мы напишем настолько простой и
чистый код, который только сможем. Это познакомит нас ближе с основными
техниками и принесет понимание, как именно язык должен себя вести.

Java прекрасно для этого подходит. Она достаточно высокоуровневая, чтобы мы не
заостряли внимание на мелких деталях реализации, но, тем не менее, достаточно
явная. В отличие от скриптовых языков, она старается держать меньше магии под
капотом иимеет статические типы, позволяющие видеть, с какими структурами данных
вы работаете.

Кроме того, я выбрал её именно потому, что она *объектно-ориентированная*. Эта
парадигма захватила мир программирования в 90-ых и сейчас это наиболее
распространенный способ мышления среди миллионов программистов. Большинство из
вас так же думает о вещах посредством классов и методов, так что мы останемся в
комфортной для вас зоне.

Хотя академические создатели языков иногда смотрят на объектно-ориентированную
парадигму свысока, реальность заключается в том, что она широко используется
даже в сфере разработки языков. GCC и LLVM написаны на C++, как и большинство
виртуальных машин JavaScript. Объектно-ориентированные языки вездесущи, а
инструменты и компиляторы *для* языка часто написаны *на* <span name="host">том
же самом языке</span>.

<aside name="host">

Компилятор читает файлы на одном языке и транслирует их в файлы на другом языке.
Вы можете реализовать компилятор на любом языке, включая тот язык, который он
компилирует. Это называется **"самодостаточость"** (self-hosting).

Вы не можете скомпилировать такой компилятор при помощи него самого, но, если у
вас есть другой компилятор вашего языка, написанный на каком-то другом языке, вы
можете использовать *его*, чтобы скомпилировать ваш компилятор. Теперь вы можете
использовать скомпилированную версию своего компилятора, чтобы компилировать его
будущие версии, и вы можете выкинуть предыдущую, скомпилированную другим
компилятором. Это называется **бутстраппинг** (bootstrapping). Такое название
произошло от ситуации, когда вы тянете себя за петельки на своих ботинках.

![Факт: Это основной способ перемещения Американских ковбоев.](image/introduction/bootstrap.png)

</aside>

И, наконец, Java очень популярна. А значит есть большая вероятность, что вы уже
её знаете, так что для чтения этой книги вам нужно будет меньше учить. Если вы
не знакомы с Java, не переживайте. Я попробую использовать как можно меньшее её
подмножество. Я использую оператор "diamond" из Java 7, чтобы сделать код более
лаконичным, но это все, что касается "продвинутых" возможностей языка. Если вы
знаете другой объектно-ориентированный язык, например, C# или C++, вы должны
разобраться.

К концу части II, мы получим простую и читаемую реализацию. Чего у нас не будет,
так это *быстрой* реализации. Это в том числе из-за особенностей виртуальной
машины Java, но мы хотим изучить, как Java *сама* реализует эти вещи.

## Второй интерпретатор

Итак, в следующей части мы начнем все с начала, но на этот раз на C. C -- это
прекрасный язык для понимания как *действительно* работают реализации, на всем
пути вниз до байтов в памяти и кода, протекающего через CPU.

Одна из основных причин использования C -- это то, что я покажу вам вещи, в
которых C действительно хорош, но это *значит*, что вам необходимо довольно
ловко обращаться с ним. Вам не нужно быть реинкарнацией Денниса Ритчи, но и
указатели не должны вас пугать.

Если вы еще не настолько хорошо знаете С, приобретите вводную книгу и прочитайте
её, после чего возвращайтесь. Взамен, к концу этой книги вы будете еще и более
сильным программистом на C. Это пойдет вам на пользу, учитывая сколько
реализаций написаны на C, как-то: Lua, CPython и Ruby MRI и т. д.

В нашем интерпретаторе на C, под названием <span name="clox">clox</span>, мы
вынуждены реализовать для себя все те вещи, которые Java давала нам бесплатно.
Мы напишем наши собственные динамические массивы и хэш таблицы. Мы решим, как
объекты будут расположены в памяти и построим собственный сборщик мусора.

<aside name="clox">

Я произношу название как "си-локс", но вы можете говорить "клокс", или даже 
"клохс", произнося "x" по-гречески, если вам угодно.

</aside>

Наша реализация на Java фокусировалась на корректности. Теперь, когда мы
опустились так низко, мы сосредоточимся на *скорости*. Наш интерпретатор на C
будет содержать <span name="compiler">компилятор</span>, который транслирует код
в эффективное байт-код представление (не волнуйтесь, я скоро объясню, что это
значит), который он затем будет исполнять. Эта же техника используется в
реализациях Lua, Python, Ruby, PHP и многих других успешных языков.

<aside name="compiler">

Вы думали это книга только об интерпретаторах? А она еще и о компиляторах. Два
по цене одного!

</aside>

Мы также попробуем своими руками провести тесты производительности и
оптимизации. К концу мы получим крепкий, точный, быстрый интерпретатор для
нашего языка, способный конкурировать с другими профессиональными
реализациями. Неплохо для одной книги и нескольких тысяч строк кода.

<div class="challenges">

## Задачи

1. Есть по крайней мере шесть предметно-ориентированных языков, используемых в 
   [маленькой системе, которую я сколотил][repo], чтобы написать и опубликовать
   эту книгу. Какие?

1. Возьмите программу "Hello, world!", написанную на Java. Настройте Makefile
   или проект в IDE, чтобы она заработала. Если у вас есть отладчик, освойтесь с
   ним и пошагайте в нем по вашей программе.

1. Сделайте тоже самое для C. Чтобы попрактивоваться с указателями, определите
   [двусвязный список][] динамически выделяемых строк. Напишите для него функции
   вставки, поиска и удаления элементов. Протестируйте их.

[repo]: https://github.com/munificent/craftinginterpreters
[doubly-linked list]: https://en.wikipedia.org/wiki/Doubly_linked_list

</div>

<div class="design-note">

## Рабочая заметка: что такого с именем?

Одним из сложнейших испытаний в процессе написания этой книги было разобраться с
именем языка, который здесь реализуется. Я перепробовал целые *страницы*
кандидатов, прежде чем нашел тот, который подходит. Как вы увидите в первый день
разработки собственного языка, именование на удивление тяжело. Хорошее имя
должно удовлетворять следующим критериям:

1. **Оно еще никем не используется.** У вас могут быть проблемы, юридические или
   социальные, если вы ненароком наткнетесь на чье-то чужое имя.

2. **Оно имеет простое произношение.** Если дело пойдет хорошо, полчища людей
   будут произносить и писать имя вашего языка. Что-то большее, чем несколько
   слогов или букв, будет постоянно их бесить.

3. **Оно достаточно уникальное, для поиска.** Люди будут гуглить название вашего
   языка, чтобы найти информацию о нем, так что вам нужно слово, достаточно
   редкое для того, чтобы большинство результатов указывали на вашу
   документацию. Хотя, с тем количеством искусственного интеллекта, которое
   используется большинством поисковых движков сейчас, это не такая большая
   проблема. Тем не менее, вы не получите от ваших пользователей хоть какой-то
   благодарности, если назовете свой язык "for".

4. **Оно не содержит негативных отсылок к каким-либо культурам.** От этого
   тяжело защититься, но лучше это учесть. Разработчик языка Nimrod в итоге
   сократил название до "Nim", потому что слишком многие люди помнят, что Багз
   Банни использовал слово "Nimrod" как оскорбление.

Если потенциальное имя удовлетворяет этим пунктам, берите его. Не зацикливайтесь
на поиске названия, которое охватывает всю суть вашего языка. Если названия
самых популярных языков в мире чему-то нас и научили, так это тому, что
название не значит почти ничего. Все, что вам нужно - это просто достаточно
уникальное обозначение.

</div>
